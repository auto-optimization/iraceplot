---
title: "Report generated by the iraceplot package"
output: 
  html_document:
    toc: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include= FALSE}
if (!exists("interactive_plots")) interactive_plots <- base::interactive()
if (interactive_plots) {
  # FIXME: Move show_table to the package so people can use it to create their
  # own reports.
  show_table <- function(x, row.names = FALSE, search = FALSE, lengthMenu = NULL, searchHighlight = TRUE, dom='lrtip', colorbar = NULL, style = list(), ...) {
    if (search) dom <- sub("r", "fr", dom)
    if (is.null(lengthMenu)) { pageLength <- NULL
    } else {
      pageLength <- lengthMenu[1]
      if (nrow(x) <= pageLength) dom <- gsub("[lip]", "", dom) # autoHideNavigation
    }
    columnDefs <- list(list(className = 'dt-right', targets = "_all"))
    tab <- DT::datatable(x, rownames = row.names,
                         class = 'compact row-border hover',
                         autoHideNavigation = TRUE,
                         options = list(
                           searchHighlight = search,
                           scrollX = TRUE,
                           pageLength=pageLength,
                           lengthMenu = lengthMenu,
                           dom = dom,
                           columnDefs = columnDefs)) %>%
      DT::formatStyle(colnames(x), fontSize='85%')
    for (col in colorbar) {
      if(!(col %in% colnames(x)))
        stop("Column ", col, " not found in table: ", paste0(colnames(x), collapse=", "))
      tab <- DT::formatStyle(tab, columns = col,
                             background = DT::styleColorBar(range(x[, col]), 'lightblue'),
                             backgroundSize = '98% 88%',
                             backgroundRepeat = 'no-repeat',
                             backgroundPosition = 'center')
    }
    for (s in style) {
      tab <- do.call(DT::formatStyle, c(table=tab, s))
    }
    tab
  }
} else {
  show_table <- function(x, row.names, ...)
    knitr::kable(x, row.names = row.names)
}

library(iraceplot)
library(tidyr, quietly = TRUE)
library(dplyr, quietly = TRUE)
# TODO: create a function summary_by_iteration that creates this table.
niterations <- length(irace_results$allElites)
ninstances <- nrow(irace_results$experiments)
byiterations <- as_tibble(irace_results$experimentLog) %>%
    group_by(iteration) %>%
    summarise(configurations = n_distinct(configuration),
              instances = n_distinct(instance), experiments=n()) %>%
    mutate(elites = sapply(irace_results$allElites, length),
           best_id = irace_results$iterationElites)

instances <- irace_results$scenario$instances[irace_results$state$.irace$instancesList[1:nrow(irace_results$experiments), "instance"]]

# FIXME: There must be a faster/easier way to do this.
freq_count <- function(x) {
  x <- table(x)
  setNames(as.vector(x), names(x))
}
exp_by_instance <- freq_count(instances[irace_results$experimentLog[,"instance"]])
seeds_by_instance <- freq_count(instances)
# TODO: create a function summary_by_instance that creates this table.
byinstance <- as_tibble(irace_results$experiments) %>%
  mutate(instance = instances, .before=1) %>%
  pivot_longer(!c("instance"), names_to="ID") %>%
  group_by(instance) %>% drop_na() %>%
  summarise(mean = mean(value), sd = sd(value), median = median(value),
            min = min(value), max = max(value),
            best_id = ID[which.min(value)]) %>%
  # Sort by the original order in instancesList
  arrange(factor(instance, levels = unique(instances))) %>%
  mutate(seeds = seeds_by_instance[instance], .after="instance") %>%
  mutate(experiments = exp_by_instance[instance], .after="instance")

basename_inst <- basename(byinstance$instance)
if (length(basename_inst) == length(byinstance$instance)) {
  byinstance <- byinstance %>% mutate(instance = basename_inst)
}

best_elites <- as.character(irace_results$allElites[[length(irace_results$allElites)]])
# TODO: Create a function summary() that reports this general information as a tibble.
```

# Scenario
<details>
<summary>Click to show</summary>
<pre>
```{r, echo=FALSE, eval=TRUE, results='asis'}
irace::printScenario(irace_results$scenario)
```
</pre>
</details> 


# General information

- irace version: `r {irace_results$irace.version}`
- Iterations: `r {niterations}`
- Configurations: `r {nrow(irace_results$allConfigurations)}`
- Instances: `r {ninstances}`
- Experiments: `r {nrow(irace_results$experimentLog)}`
- Elite configurations: `r {length(irace_results$allElites[[niterations]])}`
- Test type: `r {irace_results$scenario$testType}`
- Soft restarts: `r {any(irace_results$softRestart)}`
- Rejected configurations: `r {length(irace_results$state$rejectedIDs)}`

## By iteration

```{r,fig.align="center", echo=FALSE}
show_table(byiterations, lengthMenu = c(20, 50, 100),
           colorbar = c("configurations", "instances", "experiments", "elites"))
```

## By instance

```{r,fig.align="center", echo=FALSE}
show_table(byinstance, lengthMenu = c(20, 50, 100), search = TRUE,
           colorbar = c("experiments", "mean", "sd", "median", "min", "max"))
#columnDefs = list(list(targets = -1, searchable = FALSE))
```



# Elite configurations

The final best configurations found by irace are:

```{r,fig.align="center", echo=FALSE}
show_table(irace_results$allConfigurations[best_elites, , drop=FALSE],
           lengthMenu = c(10,20))
```

## Parallel coordinates visualization (only elites)

```{r,fig.align="center", out.width="100%", echo=FALSE}
parallel_coord(irace_results)
```

# Sampling model

The frequency of the parameter values sampled by irace:

```{r,fig.align="center", out.width="100%", echo=FALSE}
sampling_frequency(irace_results)
```


# Performance

## Testing performance

- Number of elites tested: `r {irace_results$scenario$testNbElites}`
- Iteration elites tested: `r {irace_results$scenario$testIterationElites}`

Performance of the elite configurations on the test instances:

```{r,fig.align="center", echo=FALSE}
if (has_testing_data(irace_results)) {
# FIXME: Move this table generation to a function inside the package.
tested_elites <- colnames(irace_results$testing$experiments)
best_results <- as_tibble(irace_results$testing$experiments[, tested_elites])
best_results <- best_results %>% pivot_longer(all_of(tested_elites), names_to="ID") %>% group_by(ID) %>% summarise(n_instances = sum(!is.na(value)), mean = mean(value), sd = sd(value), median = median(value), min = min(value), max = max(value))
best_results <- best_results[match(tested_elites, best_results$ID), , drop = FALSE]
show_table(best_results, lengthMenu = c(5, 10),
           colorbar = c("mean", "sd", "median", "min", "max"))
} else {
  cat("No test instances given.\n")
}
```

The final elite configuration performance on the test set:

```{r,fig.align="center", out.width="100%", echo=FALSE}
if (has_testing_data(irace_results)) {
  boxplot_test(irace_results, type = "best")
} else {
  cat("No test instances given.\n")
}
```
```{r,fig.align="center", out.width="100%", echo=FALSE}
if (has_testing_data(irace_results))
  boxplot_test(irace_results, type = "best", rpd = FALSE)
```

Iteration elite configuration performance on the test set:

```{r,fig.align="center", out.width="100%", echo=FALSE}
if (irace_results$scenario$testIterationElites && has_testing_data(irace_results)) {
   boxplot_test(irace_results, type = "all", show_points=FALSE)
} else{
  cat("Iteration elites were not tested.\n")
}
```

## Training performance 

Performance of the final elite configurations on the training instances:

```{r,fig.align="center", echo=FALSE}
best_results <- as_tibble(irace_results$experiments[, best_elites])
best_results <- best_results %>% pivot_longer(all_of(best_elites), names_to="ID") %>% group_by(ID) %>% summarise(n_instances = sum(!is.na(value)), mean = mean(value), sd = sd(value), median = median(value), min = min(value), max = max(value))
best_results <- best_results[match(best_elites, best_results$ID), , drop = FALSE]
show_table(best_results, lengthMenu = c(10, 20, 50, 100),
           colorbar = c("mean", "sd", "median", "min", "max"))
```

Final elite configurations performance on the training set:

```{r,fig.align="center", out.width="100%", echo=FALSE}
boxplot_training(irace_results)
boxplot_training(irace_results, rpd = FALSE)
```

```{asis, echo=irace_results$scenario$testIterationElites}
Iteration elites performance on the training set:
```
```{r,fig.align="center", out.width="100%", echo=FALSE, eval=irace_results$scenario$testIterationElites}
# FIXME: This should boxplot_training(irace_results, type="ibest")
boxplot_performance(experiments = irace_results$experiments,
                    allElites = lapply(irace_results$allElites, utils::head, irace_results$scenario$testNbElites),
                    type = "ibest")
boxplot_performance(experiments = irace_results$experiments,
                    allElites = lapply(irace_results$allElites, utils::head, irace_results$scenario$testNbElites),
                    type = "ibest", rpd = FALSE)
```

# Races overview

```{r,fig.align="center", out.width="100%", echo=FALSE}
plot_experiments_matrix(irace_results, interactive = interactive_plots)
```


